<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Block - æµ‹è¯•ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }
        .score-item {
            text-align: center;
        }
        .score-label {
            color: #666;
            font-size: 0.9em;
        }
        .score-value {
            color: #333;
            font-size: 2em;
            font-weight: 700;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            background: #fff;
        }
        button {
            padding: 15px 40px;
            font-size: 1em;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .debug {
            margin-top: 20px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            font-size: 0.9em;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ¨ Color Block - æµ‹è¯•ç‰ˆ</h1>
        
        <div class="score-board">
            <div class="score-item">
                <div class="score-label">å½“å‰åˆ†æ•°</div>
                <div class="score-value" id="currentScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">æœ€é«˜åˆ†</div>
                <div class="score-value" id="highScore">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="480" height="480"></canvas>

        <button id="restartBtn">ğŸ”„ é‡æ–°å¼€å§‹</button>
        
        <div class="debug" id="debug">ç‚¹å‡»Canvasæµ‹è¯•...</div>
    </div>

    <script>
        // è°ƒè¯•ä¿¡æ¯å‡½æ•°
        function debug(msg) {
            const debugDiv = document.getElementById('debug');
            debugDiv.innerHTML += '<br>' + msg;
            console.log(msg);
        }

        debug('è„šæœ¬å¼€å§‹åŠ è½½...');

        class ColorBlockGame {
            constructor() {
                debug('æ¸¸æˆåˆå§‹åŒ–...');
                
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) {
                    debug('é”™è¯¯ï¼šæ‰¾ä¸åˆ°Canvaså…ƒç´ ï¼');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    debug('é”™è¯¯ï¼šæ— æ³•è·å–Canvasä¸Šä¸‹æ–‡ï¼');
                    return;
                }
                
                debug('Canvasåˆå§‹åŒ–æˆåŠŸ');
                
                this.gridSize = 8;
                this.blockSize = 60;
                this.colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
                this.grid = [];
                this.score = 0;
                this.highScore = localStorage.getItem('colorBlockHighScore') || 0;
                this.animating = false;
                this.isGameOver = false;

                this.init();
                this.setupEventListeners();
                
                debug('æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼å¯ä»¥å¼€å§‹ç©äº†');
            }

            init() {
                debug('åˆå§‹åŒ–æ¸¸æˆç½‘æ ¼...');
                this.grid = [];
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        this.grid[row][col] = this.getRandomColor();
                    }
                }
                this.score = 0;
                this.isGameOver = false;
                this.updateScore();
                this.draw();
                debug('ç½‘æ ¼åˆå§‹åŒ–å®Œæˆï¼Œå·²ç»˜åˆ¶');
            }

            getRandomColor() {
                return this.colors[Math.floor(Math.random() * this.colors.length)];
            }

            setupEventListeners() {
                debug('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...');
                
                this.canvas.addEventListener('click', (e) => {
                    debug('Canvasè¢«ç‚¹å‡»ï¼');
                    if (this.animating || this.isGameOver) {
                        debug('æ¸¸æˆæ­£åœ¨åŠ¨ç”»ä¸­æˆ–å·²ç»“æŸï¼Œå¿½ç•¥ç‚¹å‡»');
                        return;
                    }

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const col = Math.floor(x / this.blockSize);
                    const row = Math.floor(y / this.blockSize);

                    debug(`ç‚¹å‡»ä½ç½®ï¼šè¡Œ${row}, åˆ—${col}`);
                    this.handleClick(row, col);
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.animating || this.isGameOver) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const col = Math.floor(x / this.blockSize);
                    const row = Math.floor(y / this.blockSize);

                    this.highlightedCell = { row, col };
                    this.draw();
                });
                
                debug('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
            }

            handleClick(row, col) {
                if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) {
                    debug('ç‚¹å‡»ä½ç½®è¶…å‡ºèŒƒå›´');
                    return;
                }

                const color = this.grid[row][col];
                if (!color) {
                    debug('ç‚¹å‡»ä½ç½®æ²¡æœ‰æ–¹å—');
                    return;
                }

                const connectedBlocks = this.findConnectedBlocks(row, col, color);
                debug(`æ‰¾åˆ°${connectedBlocks.length}ä¸ªè¿æ¥çš„æ–¹å—`);

                if (connectedBlocks.length <= 1) {
                    debug('åªæœ‰1ä¸ªæ–¹å—ï¼Œæ— æ³•æ¶ˆé™¤');
                    return;
                }

                // è®¡ç®—åˆ†æ•°
                const points = connectedBlocks.length * connectedBlocks.length * 10;
                this.score += points;
                this.updateScore();
                debug(`æ¶ˆé™¤${connectedBlocks.length}ä¸ªæ–¹å—ï¼Œè·å¾—${points}åˆ†ï¼`);

                // ç§»é™¤æ–¹å—
                connectedBlocks.forEach(([r, c]) => {
                    this.grid[r][c] = null;
                });

                this.animating = true;
                setTimeout(() => {
                    this.applyGravity();
                    this.fillEmpty();
                    this.draw();
                    this.animating = false;

                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                    if (this.checkGameOver()) {
                        this.endGame();
                    }
                }, 300);

                this.draw();
            }

            findConnectedBlocks(row, col, color, visited = new Set()) {
                const key = `${row},${col}`;
                if (visited.has(key)) return [];
                if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) return [];
                if (this.grid[row][col] !== color) return [];

                visited.add(key);
                let blocks = [[row, col]];

                blocks = blocks.concat(this.findConnectedBlocks(row - 1, col, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row + 1, col, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row, col - 1, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row, col + 1, color, visited));

                return blocks;
            }

            applyGravity() {
                for (let col = 0; col < this.gridSize; col++) {
                    let writeRow = this.gridSize - 1;
                    for (let row = this.gridSize - 1; row >= 0; row--) {
                        if (this.grid[row][col] !== null) {
                            if (row !== writeRow) {
                                this.grid[writeRow][col] = this.grid[row][col];
                                this.grid[row][col] = null;
                            }
                            writeRow--;
                        }
                    }
                }
            }

            fillEmpty() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === null) {
                            this.grid[row][col] = this.getRandomColor();
                        }
                    }
                }
            }

            checkGameOver() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const color = this.grid[row][col];
                        const connected = this.findConnectedBlocks(row, col, color);
                        if (connected.length > 1) {
                            return false;
                        }
                    }
                }
                return true;
            }

            endGame() {
                this.isGameOver = true;
                debug('æ¸¸æˆç»“æŸï¼');
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('colorBlockHighScore', this.highScore);
                    this.updateScore();
                    debug('æ–°çºªå½•ï¼');
                }
                alert('æ¸¸æˆç»“æŸï¼æ²¡æœ‰æ›´å¤šå¯æ¶ˆé™¤çš„æ–¹å—äº†ã€‚\nä½ çš„å¾—åˆ†ï¼š' + this.score);
            }

            updateScore() {
                document.getElementById('currentScore').textContent = this.score;
                document.getElementById('highScore').textContent = this.highScore;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = col * this.blockSize;
                        const y = row * this.blockSize;
                        const color = this.grid[row][col];

                        if (color) {
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);

                            const gradient = this.ctx.createLinearGradient(x, y, x, y + this.blockSize);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);

                            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);
                        }

                        if (this.highlightedCell &&
                            this.highlightedCell.row === row &&
                            this.highlightedCell.col === col &&
                            color) {
                            const connected = this.findConnectedBlocks(row, col, color);
                            if (connected.length > 1) {
                                connected.forEach(([r, c]) => {
                                    const hx = c * this.blockSize;
                                    const hy = r * this.blockSize;
                                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                                    this.ctx.lineWidth = 4;
                                    this.ctx.strokeRect(hx + 2, hy + 2, this.blockSize - 4, this.blockSize - 4);
                                });
                            }
                        }
                    }
                }
            }

            restart() {
                debug('é‡æ–°å¼€å§‹æ¸¸æˆ');
                this.init();
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        debug('å‡†å¤‡åˆ›å»ºæ¸¸æˆå®ä¾‹...');
        let game;
        
        window.addEventListener('DOMContentLoaded', () => {
            debug('é¡µé¢DOMåŠ è½½å®Œæˆ');
            game = new ColorBlockGame();
            
            // ç»‘å®šé‡å¯æŒ‰é’®
            document.getElementById('restartBtn').addEventListener('click', () => {
                debug('é‡å¯æŒ‰é’®è¢«ç‚¹å‡»');
                game.restart();
            });
        });
    </script>
</body>
</html>
