<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Block - Macä¼‘é—²æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-value {
            color: #333;
            font-size: 2em;
            font-weight: 700;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            background: #fff;
        }

        .button-container {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        button {
            padding: 15px 40px;
            font-size: 1em;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .instructions {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            color: #555;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .instructions h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .game-over {
            text-align: center;
            padding: 30px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            color: #e74c3c;
            margin-bottom: 10px;
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .score-popup {
            position: fixed;
            color: #fff;
            font-weight: bold;
            font-size: 1.5em;
            pointer-events: none;
            animation: popIn 0.5s ease-out;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ¨ Color Block</h1>
        <p class="subtitle">ç‚¹å‡»ç›¸åŒé¢œè‰²çš„æ–¹å—è¿›è¡Œæ¶ˆé™¤</p>

        <div class="score-board">
            <div class="score-item">
                <div class="score-label">å½“å‰åˆ†æ•°</div>
                <div class="score-value" id="currentScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">æœ€é«˜åˆ†</div>
                <div class="score-value" id="highScore">0</div>
            </div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>ğŸ® æ¸¸æˆç»“æŸï¼</h2>
            <p>æ²¡æœ‰æ›´å¤šå¯æ¶ˆé™¤çš„æ–¹å—äº†</p>
        </div>

        <canvas id="gameCanvas" width="480" height="480"></canvas>

        <div class="button-container">
            <button onclick="game.restart()">ğŸ”„ é‡æ–°å¼€å§‹</button>
        </div>

        <div class="instructions">
            <h3>ğŸ“– æ¸¸æˆè¯´æ˜</h3>
            <ul>
                <li>ç‚¹å‡»ä»»æ„æ–¹å—ï¼Œæ‰€æœ‰ç›¸é‚»çš„åŒè‰²æ–¹å—å°†è¢«æ¶ˆé™¤</li>
                <li>æ¶ˆé™¤çš„æ–¹å—è¶Šå¤šï¼Œå¾—åˆ†è¶Šé«˜ï¼ˆåˆ†æ•° = æ–¹å—æ•°Â² Ã— 10ï¼‰</li>
                <li>æ–¹å—æ¶ˆé™¤åï¼Œä¸Šæ–¹æ–¹å—ä¼šä¸‹è½ï¼Œé¡¶éƒ¨ä¼šç”Ÿæˆæ–°æ–¹å—</li>
                <li>å½“æ²¡æœ‰å¯æ¶ˆé™¤çš„æ–¹å—æ—¶ï¼Œæ¸¸æˆç»“æŸ</li>
                <li>æŒ‘æˆ˜ä½ çš„æœ€é«˜åˆ†ï¼</li>
            </ul>
        </div>
    </div>

    <script>
        class ColorBlockGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 8;
                this.blockSize = 60;
                this.colors = [
                    '#FF6B6B', // çº¢è‰²
                    '#4ECDC4', // é’è‰²
                    '#45B7D1', // è“è‰²
                    '#FFA07A', // æ©™è‰²
                    '#98D8C8', // ç»¿è‰²
                ];
                this.grid = [];
                this.score = 0;
                this.highScore = localStorage.getItem('colorBlockHighScore') || 0;
                this.animating = false;
                this.isGameOver = false;

                this.init();
                this.setupEventListeners();
            }

            init() {
                this.grid = [];
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        this.grid[row][col] = this.getRandomColor();
                    }
                }
                this.score = 0;
                this.isGameOver = false;
                this.updateScore();
                this.draw();
                document.getElementById('gameOver').classList.remove('show');
            }

            getRandomColor() {
                return this.colors[Math.floor(Math.random() * this.colors.length)];
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.animating || this.isGameOver) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const col = Math.floor(x / this.blockSize);
                    const row = Math.floor(y / this.blockSize);

                    this.handleClick(row, col);
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.animating || this.isGameOver) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const col = Math.floor(x / this.blockSize);
                    const row = Math.floor(y / this.blockSize);

                    this.highlightedCell = { row, col };
                    this.draw();
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.highlightedCell = null;
                    this.draw();
                });
            }

            handleClick(row, col) {
                if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) return;

                const color = this.grid[row][col];
                if (!color) return;

                const connectedBlocks = this.findConnectedBlocks(row, col, color);

                if (connectedBlocks.length <= 1) return;

                // è®¡ç®—åˆ†æ•°
                const points = connectedBlocks.length * connectedBlocks.length * 10;
                this.score += points;
                this.updateScore();

                // æ˜¾ç¤ºåˆ†æ•°å¼¹å‡º
                this.showScorePopup(points, col * this.blockSize + this.blockSize / 2,
                                    row * this.blockSize + this.blockSize / 2);

                // ç§»é™¤æ–¹å—
                connectedBlocks.forEach(([r, c]) => {
                    this.grid[r][c] = null;
                });

                this.animating = true;
                setTimeout(() => {
                    this.applyGravity();
                    this.fillEmpty();
                    this.draw();
                    this.animating = false;

                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                    if (this.checkGameOver()) {
                        this.endGame();
                    }
                }, 300);

                this.draw();
            }

            findConnectedBlocks(row, col, color, visited = new Set()) {
                const key = `${row},${col}`;
                if (visited.has(key)) return [];
                if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) return [];
                if (this.grid[row][col] !== color) return [];

                visited.add(key);
                let blocks = [[row, col]];

                // æ£€æŸ¥å››ä¸ªæ–¹å‘
                blocks = blocks.concat(this.findConnectedBlocks(row - 1, col, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row + 1, col, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row, col - 1, color, visited));
                blocks = blocks.concat(this.findConnectedBlocks(row, col + 1, color, visited));

                return blocks;
            }

            applyGravity() {
                for (let col = 0; col < this.gridSize; col++) {
                    let writeRow = this.gridSize - 1;
                    for (let row = this.gridSize - 1; row >= 0; row--) {
                        if (this.grid[row][col] !== null) {
                            if (row !== writeRow) {
                                this.grid[writeRow][col] = this.grid[row][col];
                                this.grid[row][col] = null;
                            }
                            writeRow--;
                        }
                    }
                }
            }

            fillEmpty() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === null) {
                            this.grid[row][col] = this.getRandomColor();
                        }
                    }
                }
            }

            checkGameOver() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const color = this.grid[row][col];
                        const connected = this.findConnectedBlocks(row, col, color);
                        if (connected.length > 1) {
                            return false;
                        }
                    }
                }
                return true;
            }

            endGame() {
                this.isGameOver = true;
                document.getElementById('gameOver').classList.add('show');
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('colorBlockHighScore', this.highScore);
                    this.updateScore();
                }
            }

            showScorePopup(points, x, y) {
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = `+${points}`;

                const rect = this.canvas.getBoundingClientRect();
                popup.style.left = (rect.left + x) + 'px';
                popup.style.top = (rect.top + y) + 'px';

                document.body.appendChild(popup);

                setTimeout(() => {
                    popup.style.transition = 'all 1s ease-out';
                    popup.style.transform = 'translateY(-50px)';
                    popup.style.opacity = '0';
                }, 100);

                setTimeout(() => {
                    document.body.removeChild(popup);
                }, 1100);
            }

            updateScore() {
                document.getElementById('currentScore').textContent = this.score;
                document.getElementById('highScore').textContent = this.highScore;
            }

            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶æ–¹å—
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = col * this.blockSize;
                        const y = row * this.blockSize;
                        const color = this.grid[row][col];

                        if (color) {
                            // ç»˜åˆ¶æ–¹å—
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);

                            // æ·»åŠ é«˜å…‰æ•ˆæœ
                            const gradient = this.ctx.createLinearGradient(x, y, x, y + this.blockSize);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);

                            // ç»˜åˆ¶è¾¹æ¡†
                            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(x + 2, y + 2, this.blockSize - 4, this.blockSize - 4);
                        }

                        // é«˜äº®æ˜¾ç¤º
                        if (this.highlightedCell &&
                            this.highlightedCell.row === row &&
                            this.highlightedCell.col === col &&
                            color) {
                            const connected = this.findConnectedBlocks(row, col, color);
                            if (connected.length > 1) {
                                connected.forEach(([r, c]) => {
                                    const hx = c * this.blockSize;
                                    const hy = r * this.blockSize;
                                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                                    this.ctx.lineWidth = 4;
                                    this.ctx.strokeRect(hx + 2, hy + 2, this.blockSize - 4, this.blockSize - 4);
                                });
                            }
                        }
                    }
                }
            }

            restart() {
                this.init();
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new ColorBlockGame();
    </script>
</body>
</html>
